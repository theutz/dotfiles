#+title: Doom Emacs Config
#+description: My best attempt at building a world for myself.
#+property: header-args:emacs-lisp :tangle config.el :comments 'link'
#+startup: content

* Doom basics
** Prologue
#+begin_src emacs-lisp :comments nil
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

#+RESULTS:

Place your private configuration here! Remember, you do not need to run ~doom sync~ after modifying this file!
** Identity
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets. It is optional.

#+begin_src emacs-lisp
(setq user-full-name "Michael Utz"
      user-mail-address "michael@theutz.com")
#+end_src

#+RESULTS:
: michael@theutz.com

** Fonts
Doom exposes five (optional) variables for controlling fonts in Doom:

- ~doom-font~ :: the primary font to use
- ~doom-variable-pitch-font~ :: a non-monospace font (where applicable)
- ~doom-big-font~ :: used for ~doom-big-font-mode~; use this for presentations or streaming.
- ~doom-symbol-font~ :: for symbols
- ~doom-serif-font~ :: for the ~fixed-pitch-serif~ face

See =C-h v doom-font= for documentation and more examples of what they accept. For example:

#+begin_src emacs-lisp :results silent
(setq doom-font (font-spec :family "BlexMono Nerd Font Mono" :size 14 :weight 'medium)
      doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size 14))
#+end_src

If you or Emacs can't find your font, use =M-x describe-font= to look them up, =M-x eval-region= to execute elisp code, and =M-x doom/reload-font= to refresh your font settings. If Emacs still can't find your font, it likely wasn't installed correctly. Font issues are rarely Doom issues!
** Themes
There are two ways to load a theme. Both assume the theme is installed and available. You can either set `doom-theme' or manually load a theme with the `load-theme' function. This is the default:

#+begin_src emacs-lisp
(setq doom-theme-dark 'doom-rose-pine
      doom-theme-light 'doom-rose-pine-dawn
      doom-theme doom-theme-light)

(defun my/apply-theme (appearance)
  "Load theme, taking current system APPEARANCE into consideration."
  (mapc #'disable-theme custom-enabled-themes)
  (pcase appearance
    ('light (load-theme doom-theme-light t))
    ('dark (load-theme doom-theme-dark t))))

(add-hook 'ns-system-appearance-change-functions #'my/apply-theme)
#+end_src

#+RESULTS:
| my/apply-theme |

** Line Number Style
This determines the style of line numbers in effect. If set to `nil', line numbers are disabled. For relative line numbers, set this to `relative'.

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

#+RESULTS:
: relative

* My customizations
** Doom Info
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :eval no
:END:

Whenever you reconfigure a package, make sure to wrap your config in an ~after!~ block, otherwise Doom's defaults may override your settings. E.g.

#+begin_src emacs-lisp
(after! PACKAGE
  (setq x y))
#+end_src

The exceptions to this rule:

  - Setting file/directory variables (like ~org-directory~)
  - Setting variables which explicitly tell you to set them before their package is loaded (see =C-h v VARIABLE= to look up their documentation).
  - Setting doom variables (which start with =doom-= or =+=).

Here are some additional functions/macros that will help you configure Doom.

- ~load!~ for loading external *.el files relative to this one
- ~use-package!~ for configuring packages
- ~after!~ for running code after a package has loaded
- ~add-load-path!~ for adding directories to the ~load-path~, relative to this file. Emacs searches the ~load-path~ when you load packages with ~require~ or =use-package=.
- ~map!~ for binding new keys

To get information about any of these functions/macros, move the cursor over the highlighted symbol at press =K= (non-evil users must press =C-c c k=). This will open documentation for it, including demos of how they are used. Alternatively, use =C-h o= to look up a symbol (functions, variables, faces, etc).

You can also try =gd= (or =C-c c d=) to jump to their definition and see how they are implemented.

** Emacs

*** Server

I've set the corresponding environment variable in my =.zshenv= and =env.nu= files, so this should work without having.

#+begin_src emacs-lisp
(setq server-socket-dir (concat (or (getenv "XDG_RUNTIME_DIR")
                                    (getenv "TMPDIR")) "emacs"))

#+end_src

#+RESULTS:
: /var/folders/rb/3dlc977d1xd_5m1fz4sg3q2r0000gn/T/emacs

*** Vterm

#+begin_src emacs-lisp
(setq vterm-shell "/opt/homebrew/bin/nu")
#+end_src

#+RESULTS:
: /opt/homebrew/bin/nu

*** Line spacing

Some useful tools for toggling line spacing. You can press =SPC t s= to toggle big or small spacing. Additionally, you can configure the amount of spacing that is toggled.

Firstly, I'll setup a user defined variable that I'll use to change the line spacing.

#+begin_src emacs-lisp :results silent
(defvar toggle-line-spacing 0.4
  "Amount of line spacing to use when toggling line spacing")
#+end_src

Next, of course, we setup the actual function that does the toggling.

#+begin_src emacs-lisp :results silent
(defun toggle-line-spacing ()
  "Toggle line spacing between no extra space to a lil extra space"
  (interactive)
  (if line-spacing
      (setq line-spacing nil)
    (setq line-spacing toggle-line-spacing))
  (redraw-frame (selected-frame)))
#+end_src

And what's the point of all this if there's no keymap?

#+begin_src emacs-lisp :results silent
(map! :desc "Line spacing"
      :leader
      :n "ts"
      #'toggle-line-spacing)
#+end_src

Finally, I'll set the default value for line spacing.

#+begin_src emacs-lisp :results silent
(setq line-spacing toggle-line-spacing)
#+end_src

#+RESULTS:
: 0.4

*** Customize

While I'm generally avoiding the use of Emacs "customization" features, it is highly convenient for two things: adding safe local variables and safe local eval forms. So, I will be loading it here.

#+begin_src emacs-lisp :results silent
(load-file (concat doom-user-dir "custom.el"))
#+end_src

** Packages
*** Introduction
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :eval no
:END:

To install a package with Doom you must declare them here and run 'doom sync' on the command line, then restart Emacs for the changes to take effect -- or use 'M-x doom/reload'.

To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:

#+begin_src emacs-lisp
(package! some-package)
#+end_src

To install a package directly from a remote git repo, you must specify a `:recipe'. You'll find documentation on what `:recipe' accepts here: https://github.com/radian-software/straight.el#the-recipe-format

#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a PACKAGENAME.el file, or is located in a subdirectory of the repo, you'll need to specify `:files' in the `:recipe':

#+begin_src emacs-lisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

If you'd like to disable a package included with Doom, you can do so here with the `:disable' property:

#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src

You can override the recipe of a built in package without having to specify all the properties for `:recipe'. These will inherit the rest of its recipe from Doom or MELPA/ELPA/Emacsmirror:

#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a `:branch' to install a package from a particular branch or tag. This is required for some packages whose default branch isn't 'master' (which our package manager can't deal with; see radian-software/straight.el#279)

#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src

Use `:pin' to specify a particular commit to install.

#+begin_src emacs-lisp
(package! builtin-package :pin "1a2b3c4d5e")
#+end_src

Doom's packages are pinned to a specific commit and updated from release to release. The `unpin!' macro allows you to unpin single packages...

#+begin_src emacs-lisp
(unpin! pinned-package)
#+end_src

...or multiple packages

#+begin_src emacs-lisp
(unpin! pinned-package another-pinned-package)
#+end_src

...Or *all* packages (NOT RECOMMENDED; will likely break things)

#+begin_src emacs-lisp
(unpin! t)
#+end_src

*** Doom overrrides

**** evil-snipe

#+begin_src emacs-lisp
(after! evil-snipe
  (setq evil-snipe-scope 'buffer))
#+end_src

**** which-key

#+begin_src emacs-lisp :results silent
(after! which-key
  (setq which-key-allow-imprecise-window-fit nil))
#+end_src

**** evil

To get evil to respect visual line mode, you've gotta delcare it early.

#+begin_src emacs-lisp :results silent
(use-package-hook! evil
  :pre-init
  (setq evil-respect-visual-line-mode t)
  t)
#+end_src

But other variables are important to setup after evil loads.

#+begin_src emacs-lisp :results silent
(after! evil
  (setq evil-shift-width 2))
#+end_src

**** evil-lion

I like the idea of aligning stuff easily, but in org-mode, consistent navigation keys are better.

#+begin_src emacs-lisp :results silent
(after! evil-lion
  (map! :mode org-mode :n "ga" #'evil-lion-left)
  (map! :mode org-mode :n "gl" #'org-down-element))
#+end_src

*** Custom packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle config.el :comments both
:END:

I'll add an obligatory header to the file so we don't byte compile this.

#+begin_src emacs-lisp :tangle packages.el :comments nil :eval no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+end_src

Now we can start adding custom packages

**** just-mode

This package provides a basic minor mode for interacting with a =Justfile=.

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! just-mode)
#+end_src

It requires minimal configuration.

#+begin_src emacs-lisp
(use-package! just-mode)
#+end_src

#+RESULTS:
: t

**** justl

This package creates a listing of public Just commands and lets you execute them in a compilation buffer.

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! justl)
#+end_src

I've assigned some keymaps to make this more convenient.

#+begin_src emacs-lisp
(use-package! justl
  :config
  (let ((desc "Execute recipe")
        (fn 'justl-exec-recipe))
    (map! :desc desc
          :map just-mode-map
          :n "e"
          fn)
    (map! :desc desc
          :n "e"
          fn)))
#+end_src

#+RESULTS:
: t

**** kdl-mode

KDL is a configuration language favored by some (mostly Rust-based) programs like [[https://zellij.dev/][Zellij]]. This provides basic syntax highlighting for it.

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! kdl-mode
  :recipe (:host github
           :repo "bobuk/kdl-mode"
           :branch "main"))
#+end_src

It requires almost no configuration to use

#+begin_src emacs-lisp
(use-package! kdl-mode)
#+end_src

#+RESULTS:
: t

**** nushell-mode

***** Package setup

This little package provides some syntax highlighting.

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! nushell-mode
  :recipe (:host github
           :repo "mrkkrp/nushell-mode"))
#+end_src

And requires very little configuration.

#+begin_src emacs-lisp :results silent
(use-package! nushell-mode
  :mode "\\.nu")
#+end_src

***** org-babel functions

****** User-defined variables

I want nushell to work with org-babel, but nobody's done the dirty work yet. We'll start with the basics. We might want this command to be customizable for someone's environment.

- ~org-babel-nushell-command~

  #+name: define-org-babel-nushell-command
  #+begin_src emacs-lisp :session org-babel-nushell :results silent
  (defvar org-babel-nushell-command
    "nu"
    "The command to execute babel body code.")
  #+end_src

  #+name: org-babel-nushell-command
  #+begin_src emacs-lisp :tangle no
  org-babel-nushell-command
  #+end_src

  #+RESULTS: org-babel-nushell-command
  : nu

Additionally, since I can't be certain the specific environment emacs will be running this command in, I need to be able to pass in the nushell config files so things operate as expected in my environment.

First I'll setup a variable for the root directory where the config files live. While nushell currently defaults to the Apple-specifc XDG paths (like in =~/Library=), I don't like that. So I'll use the arch-based defaults.

- ~org-babel-nushell-config-dir~

  #+name: define-org-babel-nushell-config-dir
  #+begin_src emacs-lisp :session org-babel-nushell :results silent
  (defvar org-babel-nushell-config-dir
    (concat (file-name-as-directory (or (getenv "XDG_CONFIG_HOME")
                                        (getenv "HOME" ".config")))
            "nushell/")
    "Absolute path to the root directory where config files for nushell exist.")
  #+end_src

Then I'll create two variables for the actual config files required for successful nushell startup.

#+name: org-babel-define-config-env-file
#+begin_src emacs-lisp :session org-babel-nushell :results silent
(defvar org-babel-nushell-env-config-file
  (concat org-babel-nushell-config-dir "env.nu")
  "Absolute path to the nu file used to configure a non-interactive nushell session.")
#+end_src

#+name: org-babel-config-file
#+begin_src emacs-lisp :tangle no :session org-babel-nushell
org-babel-nushell-config-file
#+end_src

#+RESULTS: org-babel-config-file
: /Users/michael/.config/nushell/config.nu

#+name: org-babel-define-config-file
#+begin_src emacs-lisp :session org-babel-nushell :results silent
(defvar org-babel-nushell-config-file
  (concat org-babel-nushell-config-dir "config.nu")
  "Absolute path to the nu file used to configure an interactive nushell session.")
#+end_src

#+name: org-babel-env-file
#+begin_src emacs-lisp :tangle no :session org-babel-nushell
org-babel-nushell-env-config-file
#+end_src

#+RESULTS: org-babel-env-file
: /Users/michael/.config/nushell/env.nu

Lastly, I'll join them all together in a string with the ~--login~ flag.

#+name: define-org-babel-nushell-command-options
#+begin_src emacs-lisp :session org-babel-nushell :results silent
(defvar org-babel-nushell-command-options
  (mapconcat 'identity (list "--no-newline"
                             "--env-config"
                             org-babel-nushell-env-config-file
                             "--config"
                             org-babel-nushell-config-file)
             " ")
  "The command options to use when executing code")
#+end_src

Altogether, that should produce the following:

#+name: check-org-babel-nushell-command-options
#+begin_src emacs-lisp :session org-babel-nushell :tangle no
org-babel-nushell-command-options
#+end_src

#+RESULTS: check-org-babel-nushell-command-options
: --login --env-config /Users/michael/.config/nushell/env.nu --config /Users/michael/.config/nushell/config.nu

****** The execute function

Everything before this was setting us up to be able to define a function that Org Babel will use to run a block of nushell code. That function must be named with a predictable format based on the language passed when defining src blocks.

#+begin_src emacs-lisp :results silent
(defun org-babel-execute:nushell (body params)
  "Orgmode Babel NuShell evaluate function for `BODY' with `PARAMS'."
  (let* ((tmp-src-file (org-babel-temp-file "nu-src-" ".nu"))
         (processed-params (org-babel-process-params params))
         (flags (cdr (assoc :flags processed-params)))
         (args (cdr (assoc :args processed-params)))
         (full-body (org-babel-expand-body:nushell
                     body params processed-params))
         (coding-system-for-read 'utf-8)
         (coding-system-for-write 'utf-8))
    (with-temp-file tmp-src-file (insert full-body))
    (org-babel-eval (format "%s %s %s"
                            org-babel-nushell-command
                            org-babel-nushell-command-options
                            (org-babel-process-file-name tmp-src-file)) "")))
#+end_src

The function above depends on some helpers to deal with variables passed into code blocks via the ~:var~ keyword. These are pretty straightforward string processing functions.

#+begin_src emacs-lisp :results silent
(defun org-babel-expand-body:nushell (body params &optional processed-params)
  "Expand BODY according to PARAMS, return the expanded body."
  (let* ((vars (org-babel--get-vars params)))
    (org-babel-nushell-custom-vars vars body)))
#+end_src

******* Creating variables

******** Concatenating with body

#+begin_src emacs-lisp :results silent :session org-babel-nushell-parsing-variables
(defun org-babel-nushell-custom-vars (params body)
  "Append custom variables at top."
  (if (= (length params) 0)
      body
    (concat (mapconcat 'org-babel-nushell-var-to-nushell params "\n") "\n" body)))
#+end_src

#+begin_src emacs-lisp :session org-babel-nushell-parsing-variables :tangle no
(org-babel-nushell-custom-vars '(("one" . "a\n") ("two" . "b")) "my body")
#+end_src

#+RESULTS:
: let "one" = "a"
: let "two" = "b"
: my body

******** Parsing individual parameters

#+begin_src emacs-lisp :results silent :session org-babel-nushell-parsing-variables
(defun org-babel-nushell-var-to-nushell (pair)
  "Convert an elisp var into a string of go source code
specifying a var of the same value."
  (let* ((var (car pair))
         (val (cdr pair)))
    (when (symbolp val)
      (setq val (symbol-name val)))
    (while (string-match-p "\n\\'" val)
      (setq val (substring val 0 -1)))
    (format "let %S = %S" var val)))
#+end_src

#+begin_src emacs-lisp :session org-babel-nushell-parsing-variables :tangle no
(org-babel-nushell-var-to-nushell '("my_var" . "my value"))
#+end_src

#+RESULTS:
: let "my_var" = "my value"

******* Ensuring it works

Here's a code block that we can run as a sanity check to make sure this is all working.

#+begin_src nushell :dir ~ :var str="hello" :tangle no
$str | split chars
#+end_src

#+RESULTS:
: ╭───┬───╮
: │ 0 │ h │
: │ 1 │ e │
: │ 2 │ l │
: │ 3 │ l │
: │ 4 │ o │
: ╰───┴───╯

**** rose-doom-pine-emacs

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! rose-pine-doom-emacs
  :recipe (:host github
           :repo "theutz/rose-pine-doom-emacs"
           :branch "main"))
#+end_src

#+begin_src emacs-lisp
(defun doom-rose-pine-install ()
  "Copy theme files from straight repo to themes dir."
  (let* ((themes '("rose-pine"
                   "rose-pine-dawn"
                   "rose-pine-moon"))
         (suffix "-theme.el")
         (prefix (concat straight-base-dir "straight/repos/rose-pine-doom-emacs/doom-"))
         (theme-dir (concat doom-user-dir "themes/"))
         (files (mapcar (lambda (item) (concat prefix item suffix)) themes)))
    (unless (file-exists-p theme-dir)
      (make-directory theme-dir t))
    (dolist (file files)
      (when (file-exists-p file)
        (copy-file file theme-dir t)))))
(add-hook! 'doom-before-reload-hook 'doom-rose-pine-install)
#+end_src

#+RESULTS:

**** gptel

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! gptel)
#+end_src

#+begin_src emacs-lisp
(use-package! gptel
  :config
  (setq gptel-model "gpt-4")
  (add-hook! 'gptel-post-stream-hook 'gptel-auto-scroll)
  (add-hook! 'gptel-post-response-functions 'gptel-end-of-response)
  (map! :leader
        :desc "Open GPT"
        :n "og"
        #'gptel)
  (map! :localleader
        :mode gptel-mode
        :desc "Send prompt"
        :n "RET"
        #'gptel-send)
  (map! :localleader
        :mode gptel-mode
        :desc "Open gpt menu"
        :n "SPC"
        #'gptel-menu))
#+end_src

#+RESULTS:
: t

**** chezmoi.el

Chezmoi mode makes working with [[https://www.chezmoi.io/][chezmoi]] quite a bit easier by keeping the source and target in sync when you write.

#+begin_src emacs-lisp :tangle packages.el :eval no
(package! chezmoi)
#+end_src

I've setup a little sub-set of prefixes in the file-save keymap to work with some of it's commands.

#+begin_src emacs-lisp
(use-package! chezmoi
  :config
  (let ((base "fz"))
    (map! :leader :desc "chezmoi" :n base)
    (map! :leader :desc "Find in chezmoi" :n (concat base "f") #'chezmoi-find)
    (map! :leader :desc "Write to chezmoi" :n (concat base "s") #'chezmoi-write)
    (map! :leader :desc "Sync with chezmoi" :n (concat base "t") #'chezmoi-mode)
    (map! :leader :desc "Chezmoi git status" :n (concat base "o") #'chezmoi-open-other)))
#+end_src

#+RESULTS:
: t

** Modes

*** Org

Some variables need to be set before org loads.

#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/org/")
#+end_src

#+RESULTS:
: ~/Dropbox/org/

But some can run after org loads

#+begin_src emacs-lisp :results silent
(after! org
  (add-to-list 'org-modules 'org-habit)
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"             ; A task that needs doing & is ready to do
           "PROJ(p)"             ; A project, which usually contains other tasks
           "LOOP(r)"             ; A recurring task
           "STRT(s)"             ; A task that is in progress
           "WAIT(w)"             ; Something external is holding up this task
           "HOLD(h)"             ; This task is paused/on hold because of me
           "IDEA(i)"             ; An unconfirmed and unapproved task or notion
           "|"
           "DONE(d)"   ; Task successfully completed
           "KILL(k)")  ; Task was cancelled, aborted, or is no longer applicable
          (sequence
           "[ ](T)"                     ; A task that needs doing
           "[-](S)"                     ; Task is in progress
           "[?](W)"                     ; Task is being held up or paused
           "|"
           "[X](D)")                    ; Task was completed
          (sequence
           "|"
           "OKAY(o)"
           "YES(y)"
           "NO(n)"))
        org-todo-keyword-faces
        '(("[-]"  . +org-todo-active)
          ("STRT" . +org-todo-active)
          ("[?]"  . +org-todo-onhold)
          ("WAIT" . +org-todo-onhold)
          ("HOLD" . +org-todo-onhold)
          ("PROJ" . +org-todo-project)
          ("NO"   . +org-todo-cancel)
          ("KILL" . +org-todo-cancel)))
  (map! :localleader
        :mode org-mode
        :desc "org-columns"
        :n "m"
        #'org-columns)
  (map! :localleader
        :mode org-mode
        :desc "org-refile-copy"
        :n "rd"
        #'org-refile-copy)
  (map! :localleader
        :mode org-mode
        :desc "org-delete-property"
        :n "O"
        #'org-delete-property))
#+end_src

*** Nix

Use the [[https://github.com/kamadorueda/alejandra][Alejandra]] formatter.

#+begin_src emacs-lisp
(after! nix-mode
  (set-formatter! 'alejandra '("alejandra" "--quiet") :modes '(nix-mode)))
#+end_src

#+RESULTS:

For a lot of packages, we want to use the LSP to do the formatting. But not in this case.

#+begin_src emacs-lisp :results silent
(setq-hook! 'nix-mode-hook +format-with-lsp nil)
#+end_src

** Bindings

*** Doom Overrides...

**** Workspaces

#+begin_src emacs-lisp :results silent
(map! :leader
      (:when (modulep! :ui workspaces)
        (:prefix-map ("TAB" . "workspace")
         :desc "Prev workspace" "p" #'+workspace/switch-left
         :desc "Next workspace" "n" #'+workspace/switch-right
         :desc "Create workspace" "c" #'+workspace/new
         :desc "Swap workspace left" "<" #'+workspace/swap-left
         :desc "Swap workspace right" ">" #'+workspace/swap-right)))
#+end_src

*** LazyVim compatibility layer

I've got a lot of custom bindings that are meant to make switching between LazyVim and DoomEmacs less jarring.

- Sometimes it's the simple things... =e= for /explorer/.

        #+begin_src emacs-lisp :results silent
        (map! :leader :desc "Find file" :n "e" 'find-file)
        #+end_src

- Simple terminal stuff

        #+begin_src emacs-lisp :results silent
        (map! :desc "Open terminal" :nvi "C-/" '+vterm/toggle)
        #+end_src
