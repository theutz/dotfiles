#+title: NuShell Configuration
#+description: This is the helm from which I manage my shells
#+version: 0.92.2
#+startup: content

* Environment
:PROPERTIES:
:header-args:nushell: :tangle env.nu :comments both
:END:

** Prompts

*** Left Prompt

#+begin_src nushell :cache yes
def create_left_prompt [] {
    let dir = match (do --ignore-shell-errors { $env.PWD | path relative-to $nu.home-path }) {
        null => $env.PWD
        '' => '~'
        $relative_pwd => ([~ $relative_pwd] | path join)
    }

    let path_color = (if (is-admin) { ansi red_bold } else { ansi green_bold })
    let separator_color = (if (is-admin) { ansi light_red_bold } else { ansi light_green_bold })
    let path_segment = $"($path_color)($dir)"

    let path = $path_segment | str replace --all (char path_sep) $"($separator_color)(char path_sep)($path_color)"
    let overlay = overlay list | last | if $in != zero { $" (ansi yellow)\(($in)\)" } else { "" }

    $"($path)($overlay)"
}
#+end_src

#+RESULTS[e35260650063be5ad74f0280832b9bccb1643c89]:

*** Right Prompt

#+begin_src nushell :cache yes
def create_right_prompt [] {
    # create a right prompt in magenta with green separators and am/pm underlined
    let time_segment = ([
        (ansi reset)
        (ansi magenta)
        (date now | format date '%x %X') # try to respect user's locale
    ] | str join | str replace --regex --all "([/:])" $"(ansi green)${1}(ansi magenta)" |
        str replace --regex --all "([AP]M)" $"(ansi magenta_underline)${1}")

    let last_exit_code = if ($env.LAST_EXIT_CODE != 0) {([
        (ansi rb)
        ($env.LAST_EXIT_CODE)
    ] | str join)
    } else { "" }

    ([$last_exit_code, (char space), $time_segment] | str join)
}
#+end_src

#+RESULTS[fe246fb9992dc67a7f44a6bae6b99d822039e7bb]:

*** Indicators

#+begin_src nushell :cache yes
# Use nushell functions to define your right and left prompt
# $env.PROMPT_COMMAND = {|| create_left_prompt }
# FIXME: This default is not implemented in rust code as of 2023-09-08.
# $env.PROMPT_COMMAND_RIGHT = {|| create_right_prompt }

# The prompt indicators are environmental variables that represent
# the state of the prompt
$env.PROMPT_INDICATOR = {|| "> " }
$env.PROMPT_INDICATOR_VI_INSERT = {|| "> " }
$env.PROMPT_INDICATOR_VI_NORMAL = {|| ": " }
$env.PROMPT_MULTILINE_INDICATOR = {|| "::: " }

# If you want previously entered commands to have a different prompt from the usual one,
# you can uncomment one or more of the following lines.
# This can be useful if you have a 2-line prompt and it's taking up a lot of space
# because every command entered takes up 2 lines instead of 1. You can then uncomment
# the line below so that previously entered commands show with a single `ðŸš€`.
# $env.TRANSIENT_PROMPT_COMMAND = {|| "ðŸš€ " }
# $env.TRANSIENT_PROMPT_INDICATOR = {|| "" }
# $env.TRANSIENT_PROMPT_INDICATOR_VI_INSERT = {|| "" }
# $env.TRANSIENT_PROMPT_INDICATOR_VI_NORMAL = {|| "" }
# $env.TRANSIENT_PROMPT_MULTILINE_INDICATOR = {|| "" }
# $env.TRANSIENT_PROMPT_COMMAND_RIGHT = {|| "" }
#+end_src

#+RESULTS[711956e3e066907bbdcf4a631d05103fa1aea118]:

** Environment Variable Conversions

Specifies how environment variables are:

- converted from a string to a value on Nushell startup (from_string)
- converted from a value back to a string when running external commands (to_string)

Note: The conversions happen *after* config.nu is loaded

#+begin_src nushell :cache yes
$env.ENV_CONVERSIONS = {
    "PATH": {
        from_string: { |s| $s | split row (char esep) | path expand --no-symlink }
        to_string: { |v| $v | path expand --no-symlink | str join (char esep) }
    }
    "Path": {
        from_string: { |s| $s | split row (char esep) | path expand --no-symlink }
        to_string: { |v| $v | path expand --no-symlink | str join (char esep) }
    }
}
#+end_src

#+RESULTS[475f9192a2c0702705375fcbfd1c2f4d65742cdc]:

** Library Directories

Directories to search for scripts when calling source or use. The default for this is =$nu.default-config-dir/scripts=

#+name: nu-primary-lib-dir
#+begin_src nushell :tangle no :cache yes :results none
($nu.default-config-dir | path join scripts)
#+end_src

#+RESULTS[5ed25a1224323d4aa1f18220f72123762a00703d]: nu-primary-lib-dir
: /Users/michael/.config/nushell/scripts

#+begin_src nushell :var primary=nu-primary-lib-dir() :cache yes
$env.NU_LIB_DIRS = [
  $primary
  ($nu.default-config-dir | path join nu_scripts)
]
#+end_src

#+RESULTS[a44f5aecb06c47f0a534dee49f94a16ea9b5a574]:

Directories to search for plugin binaries when calling register. The default for this is =$nu.default-config-dir/plugins=

#+begin_src nushell :cache yes
$env.NU_PLUGIN_DIRS = [
  ($nu.default-config-dir | path join 'plugins') # add <nushell-config-dir>/plugins
]
#+end_src

#+RESULTS[2ae03b9a8ef622a6a644f9af2181ed946db1afc3]:

** PATH

To add entries to PATH (on Windows you might use Path), you can use the following pattern:

#+begin_src nushell :tangle no :cache yes
$env.PATH = ($env.PATH | split row (char esep) | prepend '/some/path')
#+end_src

#+RESULTS[0cb4894eccb49abb9c8241213e06ab05e74c0ff1]:

An alternate way to add entries to $env.PATH is to use the custom command ~path add~ which is built into the nushell stdlib:

#+begin_src nushell :tangle no :cache yes
use std "path add"
$env.PATH = ($env.PATH | split row (char esep))
path add /some/path
path add ($env.CARGO_HOME | path join "bin")
path add ($env.HOME | path join ".local" "bin")
$env.PATH = ($env.PATH | uniq)
#+end_src

#+RESULTS[95dd5600ce27b3edc0301edbfcc12672fc3d34f8]:

** Environment Variables

#+begin_src nushell :cache yes
$env.EDITOR = "nvim"
$env.VISUAL = "nvim"
$env.HOMEBREW_EDITOR = "emacsclient --create-frame --no-wait --alternate-editor ''"
#+end_src

#+RESULTS[14daf2817de871c7f33d2f948066da68f8a176b6]:

** Additional Files

To load from a custom file you can use:

#+begin_src nushell :tangle no :cache yes
# source ($nu.default-config-dir | path join 'custom.nu')
#+end_src

#+RESULTS[3ae8e25a5c14e4d6e6140e8a90b745f0173d385d]:

* Configuration
:PROPERTIES:
:header-args:nushell: :tangle config.nu :comments 'both'
:END:

** Themes

- For more information on defining custom themes, see https://www.nushell.sh/book/coloring_and_theming.html
- And here is the theme collection: https://github.com/nushell/nu_scripts/tree/main/themes

*** Dark

#+begin_src nushell :eval no
let dark_theme = {
    # color for nushell primitives
    separator: white
    leading_trailing_space_bg: { attr: n } # no fg, no bg, attr none effectively turns this off
    header: green_bold
    empty: blue
    # Closures can be used to choose colors for specific values.
    # The value (in this case, a bool) is piped into the closure.
    # eg) {|| if $in { 'light_cyan' } else { 'light_gray' } }
    bool: light_cyan
    int: white
    filesize: cyan
    duration: white
    date: purple
    range: white
    float: white
    string: white
    nothing: white
    binary: white
    cell-path: white
    row_index: green_bold
    record: white
    list: white
    block: white
    hints: dark_gray
    search_result: { bg: red fg: white }
    shape_and: purple_bold
    shape_binary: purple_bold
    shape_block: blue_bold
    shape_bool: light_cyan
    shape_closure: green_bold
    shape_custom: green
    shape_datetime: cyan_bold
    shape_directory: cyan
    shape_external: cyan
    shape_externalarg: green_bold
    shape_external_resolved: light_yellow_bold
    shape_filepath: cyan
    shape_flag: blue_bold
    shape_float: purple_bold
    # shapes are used to change the cli syntax highlighting
    shape_garbage: { fg: white bg: red attr: b}
    shape_globpattern: cyan_bold
    shape_int: purple_bold
    shape_internalcall: cyan_bold
    shape_keyword: cyan_bold
    shape_list: cyan_bold
    shape_literal: blue
    shape_match_pattern: green
    shape_matching_brackets: { attr: u }
    shape_nothing: light_cyan
    shape_operator: yellow
    shape_or: purple_bold
    shape_pipe: purple_bold
    shape_range: yellow_bold
    shape_record: cyan_bold
    shape_redirection: purple_bold
    shape_signature: green_bold
    shape_string: green
    shape_string_interpolation: cyan_bold
    shape_table: blue_bold
    shape_variable: purple
    shape_vardecl: purple
}
#+end_src

*** Light

#+begin_src nushell :eval no
let light_theme = {
    # color for nushell primitives
    separator: dark_gray
    leading_trailing_space_bg: { attr: n } # no fg, no bg, attr none effectively turns this off
    header: green_bold
    empty: blue
    # Closures can be used to choose colors for specific values.
    # The value (in this case, a bool) is piped into the closure.
    # eg) {|| if $in { 'dark_cyan' } else { 'dark_gray' } }
    bool: dark_cyan
    int: dark_gray
    filesize: cyan_bold
    duration: dark_gray
    date: purple
    range: dark_gray
    float: dark_gray
    string: dark_gray
    nothing: dark_gray
    binary: dark_gray
    cell-path: dark_gray
    row_index: green_bold
    record: dark_gray
    list: dark_gray
    block: dark_gray
    hints: dark_gray
    search_result: { fg: white bg: red }
    shape_and: purple_bold
    shape_binary: purple_bold
    shape_block: blue_bold
    shape_bool: light_cyan
    shape_closure: green_bold
    shape_custom: green
    shape_datetime: cyan_bold
    shape_directory: cyan
    shape_external: cyan
    shape_externalarg: green_bold
    shape_external_resolved: light_purple_bold
    shape_filepath: cyan
    shape_flag: blue_bold
    shape_float: purple_bold
    # shapes are used to change the cli syntax highlighting
    shape_garbage: { fg: white bg: red attr: b}
    shape_globpattern: cyan_bold
    shape_int: purple_bold
    shape_internalcall: cyan_bold
    shape_keyword: cyan_bold
    shape_list: cyan_bold
    shape_literal: blue
    shape_match_pattern: green
    shape_matching_brackets: { attr: u }
    shape_nothing: light_cyan
    shape_operator: yellow
    shape_or: purple_bold
    shape_pipe: purple_bold
    shape_range: yellow_bold
    shape_record: cyan_bold
    shape_redirection: purple_bold
    shape_signature: green_bold
    shape_string: green
    shape_string_interpolation: cyan_bold
    shape_table: blue_bold
    shape_variable: purple
    shape_vardecl: purple
}
#+end_src

** Completion

#+begin_src nushell :tangle no :eval no
# External completer example
# let carapace_completer = {|spans|
#     carapace $spans.0 nushell ...$spans | from json
# }
#+end_src

#+RESULTS:

** Default Config Record

The default config record. This is where much of your global configuration is setup.

#+begin_src nushell :eval no
$env.config = {
    show_banner: false # true or false to enable or disable the welcome banner at startup

    ls: {
        use_ls_colors: true # use the LS_COLORS environment variable to colorize output
        clickable_links: true # enable or disable clickable links. Your terminal has to support links.
    }

    rm: {
        always_trash: false # always act as if -t was given. Can be overridden with -p
    }

    table: {
        mode: rounded # basic, compact, compact_double, light, thin, with_love, rounded, reinforced, heavy, none, other
        index_mode: always # "always" show indexes, "never" show indexes, "auto" = show indexes when a table has "index" column
        show_empty: true # show 'empty list' and 'empty record' placeholders for command output
        padding: { left: 1, right: 1 } # a left right padding of each column in a table
        trim: {
            methodology: wrapping # wrapping or truncating
            wrapping_try_keep_words: true # A strategy used by the 'wrapping' methodology
            truncating_suffix: "..." # A suffix used by the 'truncating' methodology
        }
        header_on_separator: false # show header text on separator/border line
        # abbreviated_row_count: 10 # limit data rows from top and bottom after reaching a set point
    }

    error_style: "fancy" # "fancy" or "plain" for screen reader-friendly error messages

    # datetime_format determines what a datetime rendered in the shell would look like.
    # Behavior without this configuration point will be to "humanize" the datetime display,
    # showing something like "a day ago."
    datetime_format: {
        # normal: '%a, %d %b %Y %H:%M:%S %z'    # shows up in displays of variables or other datetime's outside of tables
        # table: '%m/%d/%y %I:%M:%S%p'          # generally shows up in tabular outputs such as ls. commenting this out will change it to the default human readable datetime format
    }

    explore: {
        status_bar_background: { fg: "#1D1F21", bg: "#C4C9C6" },
        command_bar_text: { fg: "#C4C9C6" },
        highlight: { fg: "black", bg: "yellow" },
        status: {
            error: { fg: "white", bg: "red" },
            warn: {}
            info: {}
        },
        table: {
            split_line: { fg: "#404040" },
            selected_cell: { bg: light_blue },
            selected_row: {},
            selected_column: {},
        },
    }

    history: {
        max_size: 100_000 # Session has to be reloaded for this to take effect
        sync_on_enter: true # Enable to share history between multiple sessions, else you have to close the session to write history to file
        file_format: "plaintext" # "sqlite" or "plaintext"
        isolation: false # only available with sqlite file_format. true enables history isolation, false disables it. true will allow the history to be isolated to the current session using up/down arrows. false will allow the history to be shared across all sessions.
    }

    completions: {
        case_sensitive: false # set to true to enable case-sensitive completions
        quick: true    # set this to false to prevent auto-selecting completions when only one remains
        partial: true    # set this to false to prevent partial filling of the prompt
        algorithm: "prefix"    # prefix or fuzzy
        external: {
            enable: true # set to false to prevent nushell looking into $env.PATH to find more suggestions, `false` recommended for WSL users as this look up may be very slow
            max_results: 100 # setting it lower can improve completion performance at the cost of omitting some options
            completer: null # check 'carapace_completer' above as an example
        }
        use_ls_colors: true # set this to true to enable file/path/directory completions using LS_COLORS
    }

    filesize: {
        metric: false # true => KB, MB, GB (ISO standard), false => KiB, MiB, GiB (Windows standard)
        format: "auto" # b, kb, kib, mb, mib, gb, gib, tb, tib, pb, pib, eb, eib, auto
    }

    cursor_shape: {
        emacs: line # block, underscore, line, blink_block, blink_underscore, blink_line, inherit to skip setting cursor shape (line is the default)
        vi_insert: line # block, underscore, line, blink_block, blink_underscore, blink_line, inherit to skip setting cursor shape (block is the default)
        vi_normal: block # block, underscore, line, blink_block, blink_underscore, blink_line, inherit to skip setting cursor shape (underscore is the default)
    }

    color_config: $dark_theme # if you want a more interesting theme, you can replace the empty record with `$dark_theme`, `$light_theme` or another custom record
    use_grid_icons: true
    footer_mode: "25" # always, never, number_of_rows, auto
    float_precision: 2 # the precision for displaying floats in tables
    buffer_editor: "" # command that will be used to edit the current line buffer with ctrl+o, if unset fallback to $env.EDITOR and $env.VISUAL
    use_ansi_coloring: true
    bracketed_paste: true # enable bracketed paste, currently useless on windows
    edit_mode: vi # emacs, vi
    shell_integration: true # enables terminal shell integration. Off by default, as some terminals have issues with this.
    render_right_prompt_on_last_line: false # true or false to enable or disable right prompt to be rendered on last line of the prompt.
    use_kitty_protocol: false # enables keyboard enhancement protocol implemented by kitty console, only if your terminal support this.
    highlight_resolved_externals: true # true enables highlighting of external commands in the repl resolved by which.
    recursion_limit: 50 # the maximum number of times nushell allows recursion before stopping it

    plugins: {} # Per-plugin configuration. See https://www.nushell.sh/contributor-book/plugins.html#configuration.

    plugin_gc: {
        # Configuration for plugin garbage collection
        default: {
            enabled: true # true to enable stopping of inactive plugins
            stop_after: 10sec # how long to wait after a plugin is inactive to stop it
        }
        plugins: {
            # alternate configuration for specific plugins, by name, for example:
            #
            # gstat: {
            #     enabled: false
            # }
        }
    }

    hooks: {
        pre_prompt: [{ null }] # run before the prompt is shown
        pre_execution: [{ null }] # run before the repl input is run
        env_change: {
            PWD: [{|before, after| null }] # run if the PWD environment is different since the last repl input
        }
        display_output: "if (term size).columns >= 100 { table -e } else { table }" # run to display the output of a pipeline
        command_not_found: { null } # return an error message when a command is not found
    }

    menus: [
        # Configuration for default nushell menus
        # Note the lack of source parameter
        {
            name: completion_menu
            only_buffer_difference: false
            marker: "| "
            type: {
                layout: columnar
                columns: 4
                col_width: 20     # Optional value. If missing all the screen width is used to calculate column width
                col_padding: 2
            }
            style: {
                text: green
                selected_text: { attr: r }
                description_text: yellow
                match_text: { attr: u }
                selected_match_text: { attr: ur }
            }
        }
        {
            name: ide_completion_menu
            only_buffer_difference: false
            marker: "| "
            type: {
                layout: ide
                min_completion_width: 0,
                max_completion_width: 50,
                max_completion_height: 10, # will be limited by the available lines in the terminal
                padding: 0,
                border: true,
                cursor_offset: 0,
                description_mode: "prefer_right"
                min_description_width: 0
                max_description_width: 50
                max_description_height: 10
                description_offset: 1
                # If true, the cursor pos will be corrected, so the suggestions match up with the typed text
                #
                # C:\> str
                #      str join
                #      str trim
                #      str split
                correct_cursor_pos: false
            }
            style: {
                text: green
                selected_text: { attr: r }
                description_text: yellow
                match_text: { attr: u }
                selected_match_text: { attr: ur }
            }
        }
        {
            name: history_menu
            only_buffer_difference: true
            marker: "? "
            type: {
                layout: list
                page_size: 10
            }
            style: {
                text: green
                selected_text: green_reverse
                description_text: yellow
            }
        }
        {
            name: help_menu
            only_buffer_difference: true
            marker: "? "
            type: {
                layout: description
                columns: 4
                col_width: 20     # Optional value. If missing all the screen width is used to calculate column width
                col_padding: 2
                selection_rows: 4
                description_rows: 10
            }
            style: {
                text: green
                selected_text: green_reverse
                description_text: yellow
            }
        }
    ]

    keybindings: [
        {
            name: completion_menu
            modifier: none
            keycode: tab
            mode: [emacs vi_normal vi_insert]
            event: {
                until: [
                    { send: menu name: completion_menu }
                    { send: menunext }
                    { edit: complete }
                ]
            }
        }
        {
            name: ide_completion_menu
            modifier: control
            keycode: char_n
            mode: [emacs vi_normal vi_insert]
            event: {
                until: [
                    { send: menu name: ide_completion_menu }
                    { send: menunext }
                    { edit: complete }
                ]
            }
        }
        {
            name: history_menu
            modifier: control
            keycode: char_r
            mode: [emacs, vi_insert, vi_normal]
            event: { send: menu name: history_menu }
        }
        {
            name: help_menu
            modifier: none
            keycode: f1
            mode: [emacs, vi_insert, vi_normal]
            event: { send: menu name: help_menu }
        }
        {
            name: completion_previous_menu
            modifier: shift
            keycode: backtab
            mode: [emacs, vi_normal, vi_insert]
            event: { send: menuprevious }
        }
        {
            name: next_page_menu
            modifier: control
            keycode: char_x
            mode: emacs
            event: { send: menupagenext }
        }
        {
            name: undo_or_previous_page_menu
            modifier: control
            keycode: char_z
            mode: emacs
            event: {
                until: [
                    { send: menupageprevious }
                    { edit: undo }
                ]
            }
        }
        {
            name: escape
            modifier: none
            keycode: escape
            mode: [emacs, vi_normal, vi_insert]
            event: { send: esc }    # NOTE: does not appear to work
        }
        {
            name: cancel_command
            modifier: control
            keycode: char_c
            mode: [emacs, vi_normal, vi_insert]
            event: { send: ctrlc }
        }
        {
            name: quit_shell
            modifier: control
            keycode: char_d
            mode: [emacs, vi_normal, vi_insert]
            event: { send: ctrld }
        }
        {
            name: clear_screen
            modifier: control
            keycode: char_l
            mode: [emacs, vi_normal, vi_insert]
            event: { send: clearscreen }
        }
        {
            name: search_history
            modifier: control
            keycode: char_q
            mode: [emacs, vi_normal, vi_insert]
            event: { send: searchhistory }
        }
        {
            name: open_command_editor
            modifier: control
            keycode: char_o
            mode: [emacs, vi_normal, vi_insert]
            event: { send: openeditor }
        }
        {
            name: move_up
            modifier: none
            keycode: up
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: menuup }
                    { send: up }
                ]
            }
        }
        {
            name: move_down
            modifier: none
            keycode: down
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: menudown }
                    { send: down }
                ]
            }
        }
        {
            name: move_left
            modifier: none
            keycode: left
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: menuleft }
                    { send: left }
                ]
            }
        }
        {
            name: move_right_or_take_history_hint
            modifier: none
            keycode: right
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: historyhintcomplete }
                    { send: menuright }
                    { send: right }
                ]
            }
        }
        {
            name: move_one_word_left
            modifier: control
            keycode: left
            mode: [emacs, vi_normal, vi_insert]
            event: { edit: movewordleft }
        }
        {
            name: move_one_word_right_or_take_history_hint
            modifier: control
            keycode: right
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: historyhintwordcomplete }
                    { edit: movewordright }
                ]
            }
        }
        {
            name: move_to_line_start
            modifier: none
            keycode: home
            mode: [emacs, vi_normal, vi_insert]
            event: { edit: movetolinestart }
        }
        {
            name: move_to_line_start
            modifier: control
            keycode: char_a
            mode: [emacs, vi_normal, vi_insert]
            event: { edit: movetolinestart }
        }
        {
            name: move_to_line_end_or_take_history_hint
            modifier: none
            keycode: end
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: historyhintcomplete }
                    { edit: movetolineend }
                ]
            }
        }
        {
            name: move_to_line_end_or_take_history_hint
            modifier: control
            keycode: char_e
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: historyhintcomplete }
                    { edit: movetolineend }
                ]
            }
        }
        {
            name: move_to_line_start
            modifier: control
            keycode: home
            mode: [emacs, vi_normal, vi_insert]
            event: { edit: movetolinestart }
        }
        {
            name: move_to_line_end
            modifier: control
            keycode: end
            mode: [emacs, vi_normal, vi_insert]
            event: { edit: movetolineend }
        }
        {
            name: move_up
            modifier: control
            keycode: char_p
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: menuup }
                    { send: up }
                ]
            }
        }
        {
            name: move_down
            modifier: control
            keycode: char_t
            mode: [emacs, vi_normal, vi_insert]
            event: {
                until: [
                    { send: menudown }
                    { send: down }
                ]
            }
        }
        {
            name: delete_one_character_backward
            modifier: none
            keycode: backspace
            mode: [emacs, vi_insert]
            event: { edit: backspace }
        }
        {
            name: delete_one_word_backward
            modifier: control
            keycode: backspace
            mode: [emacs, vi_insert]
            event: { edit: backspaceword }
        }
        {
            name: delete_one_character_forward
            modifier: none
            keycode: delete
            mode: [emacs, vi_insert]
            event: { edit: delete }
        }
        {
            name: delete_one_character_forward
            modifier: control
            keycode: delete
            mode: [emacs, vi_insert]
            event: { edit: delete }
        }
        {
            name: delete_one_character_backward
            modifier: control
            keycode: char_h
            mode: [emacs, vi_insert]
            event: { edit: backspace }
        }
        {
            name: delete_one_word_backward
            modifier: control
            keycode: char_w
            mode: [emacs, vi_insert]
            event: { edit: backspaceword }
        }
        {
            name: move_left
            modifier: none
            keycode: backspace
            mode: vi_normal
            event: { edit: moveleft }
        }
        {
            name: newline_or_run_command
            modifier: none
            keycode: enter
            mode: emacs
            event: { send: enter }
        }
        {
            name: newline_or_run_command
            modifier: shift
            keycode: char_o
            mode: vi_normal
            event: { edit: insertnewline }
        }
        {
            name: move_left
            modifier: control
            keycode: char_b
            mode: emacs
            event: {
                until: [
                    { send: menuleft }
                    { send: left }
                ]
            }
        }
        {
            name: move_right_or_take_history_hint
            modifier: control
            keycode: char_f
            mode: emacs
            event: {
                until: [
                    { send: historyhintcomplete }
                    { send: menuright }
                    { send: right }
                ]
            }
        }
        {
            name: redo_change
            modifier: control
            keycode: char_g
            mode: emacs
            event: { edit: redo }
        }
        {
            name: undo_change
            modifier: control
            keycode: char_z
            mode: emacs
            event: { edit: undo }
        }
        {
            name: paste_before
            modifier: control
            keycode: char_y
            mode: emacs
            event: { edit: pastecutbufferbefore }
        }
        {
            name: cut_word_left
            modifier: control
            keycode: char_w
            mode: emacs
            event: { edit: cutwordleft }
        }
        {
            name: cut_line_to_end
            modifier: control
            keycode: char_k
            mode: emacs
            event: { edit: cuttoend }
        }
        {
            name: cut_line_from_start
            modifier: control
            keycode: char_u
            mode: emacs
            event: { edit: cutfromstart }
        }
        {
            name: swap_graphemes
            modifier: control
            keycode: char_t
            mode: emacs
            event: { edit: swapgraphemes }
        }
        {
            name: move_one_word_left
            modifier: alt
            keycode: left
            mode: emacs
            event: { edit: movewordleft }
        }
        {
            name: move_one_word_right_or_take_history_hint
            modifier: alt
            keycode: right
            mode: emacs
            event: {
                until: [
                    { send: historyhintwordcomplete }
                    { edit: movewordright }
                ]
            }
        }
        {
            name: move_one_word_left
            modifier: alt
            keycode: char_b
            mode: emacs
            event: { edit: movewordleft }
        }
        {
            name: move_one_word_right_or_take_history_hint
            modifier: alt
            keycode: char_f
            mode: emacs
            event: {
                until: [
                    { send: historyhintwordcomplete }
                    { edit: movewordright }
                ]
            }
        }
        {
            name: delete_one_word_forward
            modifier: alt
            keycode: delete
            mode: emacs
            event: { edit: deleteword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: backspace
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: delete_one_word_backward
            modifier: alt
            keycode: char_m
            mode: emacs
            event: { edit: backspaceword }
        }
        {
            name: cut_word_to_right
            modifier: alt
            keycode: char_d
            mode: emacs
            event: { edit: cutwordright }
        }
        {
            name: upper_case_word
            modifier: alt
            keycode: char_u
            mode: emacs
            event: { edit: uppercaseword }
        }
        {
            name: lower_case_word
            modifier: alt
            keycode: char_l
            mode: emacs
            event: { edit: lowercaseword }
        }
        {
            name: capitalize_char
            modifier: alt
            keycode: char_c
            mode: emacs
            event: { edit: capitalizechar }
        }
        # The following bindings with `*system` events require that Nushell has
        # been compiled with the `system-clipboard` feature.
        # This should be the case for Windows, macOS, and most Linux distributions
        # Not available for example on Android (termux)
        # If you want to use the system clipboard for visual selection or to
        # paste directly, uncomment the respective lines and replace the version
        # using the internal clipboard.
        {
            name: copy_selection
            modifier: control_shift
            keycode: char_c
            mode: emacs
            event: { edit: copyselection }
            # event: { edit: copyselectionsystem }
        }
        {
            name: cut_selection
            modifier: control_shift
            keycode: char_x
            mode: emacs
            event: { edit: cutselection }
            # event: { edit: cutselectionsystem }
        }
        # {
        #     name: paste_system
        #     modifier: control_shift
        #     keycode: char_v
        #     mode: emacs
        #     event: { edit: pastesystem }
        # }
        {
            name: select_all
            modifier: control_shift
            keycode: char_a
            mode: emacs
            event: { edit: selectall }
        }
    ]
}
#+end_src

** NuShell Scripts

Load scripts from [[https://github.com/nushell/nu_scripts][nu_scripts]] repo.

*** Themes

#+begin_src nushell
# Setup nushell theme
# use nu_scripts/themes/nu-themes/rose-pine.nu
# $env.config = ($env.config | merge {color_config: (rose-pine)})
#+end_src

#+RESULTS:

*** Completions

Setup custom completions

#+begin_src nushell
use nu_scripts/custom-completions/bat/bat-completions.nu *
use nu_scripts/custom-completions/composer/composer-completions.nu *
use nu_scripts/custom-completions/curl/curl-completions.nu *
use nu_scripts/custom-completions/gh/gh-completions.nu *
use nu_scripts/custom-completions/git/git-completions.nu *
use nu_scripts/custom-completions/glow/glow-completions.nu *
use nu_scripts/custom-completions/just/just-completions.nu *
use nu_scripts/custom-completions/less/less-completions.nu *
#+end_src

#+RESULTS:

** Third-Party Setup
*** ASDF
#+begin_src nushell
$env.ASDF_DIR = (brew --prefix asdf | str trim | into string | path join 'libexec')
 source /opt/homebrew/opt/asdf/libexec/asdf.nu
#+end_src

#+RESULTS:

** Custom Modules

#+begin_src nushell
use edit.nu
use rose-pine.nu
use xdg.nu
use follow.nu
use wm.nu
use my
use chezmoi
overlay use aliases.nu
overlay use --prefix service.nu
overlay use --prefix pueue.nu
#+end_src

* Modules

Writing modules in nushell is a way to reuse code between other scripts, as well as creating command line tools.

I'd like to tangle them all into the same root directory, so I'll create a block below whose output I can use while creating header arguments for the sub-headings.

** XDG
:PROPERTIES:
:header-args:nushell: :tangle scripts/xdg.nu :comments 'both'
:END:

These are just some little scripts to make creating XDG file paths. The [[https://wiki.archlinux.org/title/XDG_Base_Directory][Arch Linux docs]] have some good details about how this is supposed to work.

*** XDG_CONFIG_HOME

- Where user-specific configurations should be written (analogous to /etc).
- Should default to =$HOME/.config=.

**** Definition

#+name: xdg-config
#+begin_src nushell :results silent
# Construct an absolute path from XDG_CONFIG_HOME
export def config [
  ...path: string # The path segments to join
] -> string {
  $env.XDG_CONFIG_HOME | default [$env.HOME .config]
    | path join ...$path
}
#+end_src

**** Example

#+name: xdg-config-example
#+begin_src nushell :noweb yes :tangle no
<<xdg-config>>
config | print
config nushell this is a really good example
#+end_src

#+RESULTS: xdg-config-example
: /Users/michael/.config
: /Users/michael/.config/nushell/this/is/a/really/good/example

*** XDG_CACHE_HOME

- Where user-specific non-essential (cached) data should be written (analogous to /var/cache).
- Should default to =$HOME/.cache=.

**** Definition

#+name: xdg-cache
#+begin_src nushell :results silent
# Construct an absolute path from XDG_CACHE_HOME
export def cache [
  ...path: string
] -> string {
  $env.XDG_CACHE_HOME
    | default ([$env.HOME .cache])
    | path join ...$path
}
#+end_src

**** Example

#+name: xdg-cache-example
#+begin_src nushell :noweb yes :tangle no
<<xdg-cache>>
cache | print
cache this is a great example actually
#+end_src

#+RESULTS: xdg-cache-example
: /Users/michael/.cache
: /Users/michael/.cache/this/is/a/great/example/actually

*** XDG_DATA_HOME

- Where user-specific data files should be written (analogous to /usr/share).
- Should default to =$HOME/.local/share=.

**** Definition

#+name: xdg-data
#+begin_src nushell :results silent
# Construct an absolute path from XDG_DATA_HOME
export def data [
  ...path: string
] -> string {
  $env.XDG_DATA_HOME
    | default ([$env.HOME .local state])
    | path join ...$path
}
#+end_src

**** Example

#+name: xdg-data-example
#+begin_src nushell :noweb yes :tangle no
<<xdg-data>>
data | print
data this is a great example actually
#+end_src

#+RESULTS: xdg-data-example
: /Users/michael/.local/share
: /Users/michael/.local/share/this/is/a/great/example/actually

*** XDG_STATE_HOME

- Where user-specific state files should be written (analogous to /var/lib).
- Should default to =$HOME/.local/state=.

**** Definition

#+name: xdg-state
#+begin_src nushell :results silent
# Construct an absolute path from XDG_STATE_HOME
export def state [
  ...path: string
] -> string {
  $env.XDG_STATE_HOME
    | default ([$env.HOME .local state])
    | path join ...$path
}
#+end_src

**** Example

#+name: xdg-state-example
#+begin_src nushell :noweb yes :tangle no
<<xdg-state>>
state | print
state this is a great example actually
#+end_src

#+RESULTS: xdg-state-example
: /Users/michael/.local/state
: /Users/michael/.local/state/this/is/a/great/example/actually

*** XDG_RUNTIME_DIR

- Used for non-essential, user-specific data files such as sockets, named pipes, etc.
- Not required to have a default value; warnings should be issued if not set or equivalents provided.
- Must be owned by the user with an access mode of 0700.
- Filesystem fully featured by standards of OS.
- Must be on the local filesystem.
- May be subject to periodic cleanup.
- Modified every 6 hours or set sticky bit if persistence is desired.
- Can only exist for the duration of the user's login.
- Should not store large files as it may be mounted as a tmpfs.
- pam_systemd sets this to =/run/user/$UID=.

**** Definition

#+name: xdg-runtime
#+begin_src nushell :results silent
# Construct an absolute path from XDG_RUNTIME_DIR
export def runtime [
  ...path: string
] -> string {
  $env.XDG_RUNTIME_DIR
    | default ([$env.HOME .local state])
    | path join ...$path
}
#+end_src

**** Example

#+name: xdg-runtime-example
#+begin_src nushell :noweb yes :tangle no
<<xdg-runtime>>
runtime | print
runtime this is a great example actually
#+end_src

#+RESULTS: xdg-runtime-example
: /var/folders/rb/3dlc977d1xd_5m1fz4sg3q2r0000gn/T/
: /var/folders/rb/3dlc977d1xd_5m1fz4sg3q2r0000gn/T/this/is/a/great/example/actually
** Pueue
:PROPERTIES:
:header-args:nushell: :tangle (expand-file-name "pueue.nu" (org-sbe nu-primary-lib-dir)) :mkdirp t
:END:

I work with [[https://github.com/Nukesor/pueue][pueue]] a lot, and I've got some convenience wrappers I like to use to make it easier to deal with it in nushell.

*** Status

This script simply wraps the status command output as a table whose shape is a bit easier to work with.

#+begin_src nushell

# Get output as table
export def status --wrapped [...args] {
  $args | filter {|x| $x != "--json" and $x != "-j"}
    | if "-h" in $in or "--help" in $in {
        ^pueue status --help
      } else {
        ^pueue status ...$in --json
          | from json
          | transpose name details
          | each { upsert details { transpose name details } }
          | reduce --fold {} {|it, acc| $acc | upsert $it.name $it.details }
      }
}
#+end_src

#+RESULTS:

** Service
:PROPERTIES:
:header-args:nushell: :tangle (expand-file-name "service.nu" (org-sbe nu-primary-lib-dir)) :comments 'link' :results silent
:END:

This module helps me start, stop, and monitor services that I run regularly via homebrew, pueue, or elsewhere.

*** Main

#+begin_src nushell
export def main [] {
    "Commands for interacting with long-running services."
}
#+end_src

We need a place to define all of our services that can be referenced from multiple commands.

#+begin_src nushell
def service-definitions [] {
    [
      [name        type  command];
      [yabai       pueue null]
      [skhd        pueue null]
      [borders     pueue null]
      [sketchybar  pueue null]
      [dark-notify pueue 'dark-notify -c "tmux source-file ~/.config/tmux/tmux.conf"']
    ]
}
#+end_src

And then we'll want a few ways to slice-and-dice those definitions.

#+begin_src nushell
def service-names [] {
  service-definitions | get name
}

def service-command [service: string@service-names] {
  service-definitions | where name == $service | get command.0
}
#+end_src

*** Start

Now, on to the meat-and-potatoes! I like using [[https://github.com/Nukesor/pueue][pueue]] to manage most of my processes. As such, I'll set up a helper function to get services started running.

#+begin_src nushell
def start-with-pueue [
    group: string, # The name of the group
    command?: string # The command to pass, else just use the group name
] {
    use pueue.nu

    pueue status | get groups | where name == $group
    | if ($in | is-empty) {
        ^pueue groups add $group
    }

    pueue status | get tasks.details | where group == $group
    | if ($in | is-empty) {
        with-env { SHELL: nu-login } {
            ^pueue add --group $group --working-directory ~ -- ($command | default $group)
        }
        ^pueue start --group $group
        } else {
            pueue status | get tasks.details
                | where group == $group
                | each { ^pueue kill $in.id }
            pueue clean --group $group
            start-with-pueue $group $command
        }
}
#+end_src

With all these pieces in place, we can now assemle our first user-facing command.

#+begin_src nushell
# Start a service
export def start [
    service: string@service-names, # The name of the service
] {
    start-with-pueue $service (service-command $service)
}
#+end_src

Now, let's check and see if it worked.

#+name: service-start-test
#+begin_src nushell :tangle no :results output replace
service start skhd
#+end_src

#+RESULTS: service-start-test
: All finished tasks have been removed from group 'skhd'
: New task added (id 36).
: Group "skhd" is being resumed.

Great! Now, it'd be good to have a way to check the status of the service.

*** Status

Again, we'll want a helper function for our pueue services.

#+begin_src nushell
def status-with-pueue [] {
  use pueue.nu

  pueue status | get tasks.details | select group status command
    | rename -c { group: service }
    | upsert status {
        match ($in | describe -d | get type) {
          record => ($in | items {|k,v| $"($k): ($v)"} | first),
          _ => $in
        }
    }
}
#+end_src

Which we can use for our user-facing command:

#+begin_src nushell
# Get the status of a running service
export def status [
    service?: string@service-names
    --verbose (-v) # Show extra output
] {
    status-with-pueue | if $verbose { $in } else { $in | reject command }
    | if ($service | is-not-empty) {
      $in | where service == $service
    } else { $in }
}
#+end_src

That produces the following output showing an overview of statuses.

- [X] Basic invocation
        #+name: service-status-test
        #+begin_src nushell :tangle no :results replace output
        service status
        #+end_src

        #+RESULTS: service-status-test
        : â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
        : â”‚ # â”‚   service   â”‚ status  â”‚
        : â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        : â”‚ 0 â”‚ dark-notify â”‚ Running â”‚
        : â”‚ 1 â”‚ sketchybar  â”‚ Running â”‚
        : â”‚ 2 â”‚ borders     â”‚ Running â”‚
        : â”‚ 3 â”‚ yabai       â”‚ Running â”‚
        : â”‚ 4 â”‚ skhd        â”‚ Running â”‚
        : â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
- [X] With verbose
        #+name: service-status-detailed-test
        #+begin_src nushell :tangle no :results replace output
        service status -v
        #+end_src

        #+RESULTS: service-status-detailed-test
        #+begin_example
        â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
        â”‚ # â”‚   service   â”‚ status  â”‚                     command                      â”‚
        â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 0 â”‚ dark-notify â”‚ Running â”‚ dark-notify -c "tmux source-file                 â”‚
        â”‚   â”‚             â”‚         â”‚ ~/.config/tmux/tmux.conf"                        â”‚
        â”‚ 1 â”‚ sketchybar  â”‚ Running â”‚ sketchybar                                       â”‚
        â”‚ 2 â”‚ borders     â”‚ Running â”‚ borders                                          â”‚
        â”‚ 3 â”‚ yabai       â”‚ Running â”‚ yabai                                            â”‚
        â”‚ 4 â”‚ skhd        â”‚ Running â”‚ skhd                                             â”‚
        â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
        #+end_example
- [X] With individual service
        #+name: service-status-single-test
        #+begin_src nushell :tangle no :results replace output
        service status skhd
        #+end_src

        #+RESULTS: service-status-single-test
        : â•­â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
        : â”‚ # â”‚ service â”‚ status  â”‚
        : â”œâ”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        : â”‚ 0 â”‚ skhd    â”‚ Running â”‚
        : â•°â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

*** Stop

We'll need to handle pueue services specially again, so I'll create another helper function for that.

#+begin_src nushell
def stop-with-pueue [group: string] {
  use pueue.nu

  pueue status | get tasks.details | where group == $group
  | each { pueue kill $in.id }

  pueue clean -g $group
}
#+end_src

#+begin_src nushell
# Stop a service
export def stop [
    service: string@service-names, # The name of the service
] {
    stop-with-pueue $service
}
#+end_src

#+name: service-stop-test
#+begin_src nushell :tangle no :results output replace
service stop skhd
#+end_src

#+RESULTS: service-stop-test
: All finished tasks have been removed from group 'skhd'

#+name: services-stop-status
#+begin_src nushell :tangle no :results output replace :noweb yes
<<service-stop-test>>
service status skhd | to text
#+end_src

#+RESULTS: services-stop-status
: All finished tasks have been removed from group 'skhd'

*** Logs

I also want a way to check out the logs for the currently running services.

**** Helper function for pueue

For that, I'll need a trusty helper function again.

#+begin_src nushell
def logs-with-pueue [
    group: string
    --follow (-f)
] {
    ^pueue status --json | from json | get tasks | values
        | where group == $group and status == Running
        | get id.0
        | do {|x|
            pueue log $x
            if ($follow) {
                pueue follow $x
            }
        } $in
}
#+end_src

**** Public facing command

And, then of course, I'll expose my public facing API

#+begin_src nushell
# View the logs for a running process
export def logs [
    service: string@service-names
    --follow (-f) # Follow logs after the initial dump
] {
    logs-with-pueue $service --follow=$follow
}
#+end_src

This should produce output like the following:

**** Normal invocation

#+name: service-logs-output
#+begin_src nushell :tangle no :results output replace
service logs skhd
#+end_src

#+RESULTS: service-logs-output

**** With follow flag
  
This command presumes there's a TTY attached, and will hang if run as a code block.

#+name: service-logs-follow
#+begin_src nushell :tangle no :results output replace :eval no
service logs skhd -f
#+end_src
*** Restart

Of course, we might want to explicitly restart one service or another. This isn't as important with pueue services, but it is for brew services. So we'll make a standard API to help with that. First, the helper function:

#+begin_src nushell
def restart-with-pueue [group: string] {
  stop-with-pueue $group
  start-with-pueue $group (service-command $group)
}
#+end_src

Now we can make the public API:

#+begin_src nushell
# Restart a service
export def restart [
  service: string@service-names, # The name of the service
] {
  restart-with-pueue $service
}
#+end_src

#+name: services-restart-test
#+begin_src nushell :tangle no :results output replace
service restart skhd
#+end_src

#+RESULTS: services-restart-test
: All finished tasks have been removed from group 'skhd'
: New task added (id 36).
: Group "skhd" is being resumed.

#+name: services-restart-status
#+begin_src nushell :tangle no :results output replace :noweb yes
<<services-restart-test>>
service status skhd | to text
#+end_src

#+RESULTS: services-restart-status
: All finished tasks have been removed from group 'skhd'
: All finished tasks have been removed from group 'skhd'
: New task added (id 36).
: Group "skhd" is being resumed.
: service: skhd
: status: Running

** Aliases
:PROPERTIES:
:header-args:nushell: :tangle (expand-file-name "aliases.nu" (org-sbe nu-primary-lib-dir)) :mkdirp t
:END:

#+begin_src nushell
use chezmoi

export alias c        = ^chezmoi
export alias e        = ^$env.EDITOR
export alias j        = just --highlight
export alias lazynvim = nvim --headless "+Lazy! sync" +qa
export alias lg       = lazygit
export alias sail     = vendor/bin/sail
export alias v        = ^$env.VISUAL
export alias q        = ^pueue

# Start yazi file manager with cd on exit
export def --env yy [...args] {
  let tmp = (mktemp -t "yazi-cwd.XXXXXX")
  yazi ...$args --cwd-file $tmp
  let cwd = (open $tmp)
  if $cwd != "" and $cwd != $env.PWD {
    cd $cwd
  }
  rm -fp $tmp
}

export def --wrapped artisan [...args] {
  if ('vendor/bin/sail' | path exists) {
    print -e "ðŸ³ Running in docker..."
    vendor/bin/sail artisan ...$args
  } else {
    php artisan ...$args
  }
}

export def --wrapped please [...args] {
  if ('vendor/bin/sail' | path exists) {
    print -e "ðŸ³ Running in docker..."
    vendor/bin/sail php please ...$args
  } else {
    php please ...$args
  }
}

export def --wrapped composer [...args] {
  if ('vendor/bin/sail' | path exists) {
    print -e "ðŸ³ Running in docker..."
    vendor/bin/sail composer ...$args
  } else {
    ^composer ...$args
  }
}
#+end_src

#+RESULTS:

** Edit
:PROPERTIES:
:header-args:nushell: :tangle (expand-file-name "edit.nu" (org-sbe nu-primary-lib-dir)) :mkdirp t
:END:

#+begin_src nushell
use xdg.nu

def editor [...args: any] {
  run-external $env.EDITOR ...$args
}

def scripts-path [
  ...paths: string
] {
  ($nu.default-config-dir | path join scripts ...$paths)
}

def enter-edit [
  ...paths: string
] {
  $paths | path join
    | match ($in | path type) {
        dir => { enter ($in) },
        _ => { enter ($in | path dirname); ($in | path basename) }
      }
    | if ($in | is-not-empty) {
        editor $in
      } else {
        editor
      }
  dexit
}

def names [context: string] {
  const both = [yabai skhd chezmoi borders sketchybar]

  ["-n" "--nushell"] | any { $context =~ $in}
    | if $in {
        [brew pueue wm follow rose-pine aliases] ++ $both
      } else {
        [tmux nvim wezterm] ++ $both
      }
    | sort
}

export def main [
  name?: string@names
  --nushell (-n)
] {
  if ($nushell) {
    scripts-path $name
    | if ($in | path exists) {
        $in
      } else if ($in | $"($in).nu" | path exists) {
        $"($in).nu"
      } else {
        print -e $"($name) is not a nushell module."
        return
      }
  } else {
    if $name == null {
      scripts-path edit.nu
    } else {
      xdg config $name | if ($in | path exists) { $in } else {
        print -e $"($in) does not exist."
        return
      }
    }
  }
  | enter-edit $in
}

#+end_src
** Rose Pine
:PROPERTIES:
:header-args:nushell: :tangle (expand-file-name "rose-pine.nu" (org-sbe nu-primary-lib-dir)) :mkdirp t :comments link
:END:

This little module is useful for setting colors other places.

*** Theme Definitions

First, we'll create a data structure we can query that defines the themes's colors in undecorated hexadecimal format.

#+begin_src nushell
def themes [] {
  [
    [role    dark   moon   dawn ];
    [base    191724 232136 faf4ed]
    [surface 1f1d2e 2a273f fffaf3]
    [overlay 26233a 393552 f2e9e1]
    [muted   6e6a86 6e6a86 9893a5]
    [subtle  908caa 908caa 797593]
    [text    e0def4 e0def4 575279]
    [love    eb6f92 eb6f92 b4637a]
    [gold    f6c177 f6c177 ea9d34]
    [rose    ebbcba ea9a97 d7827e]
    [pine    31748f 3e8fb0 286983]
    [foam    9ccfd8 9ccfd8 56949f]
    [iris    c4a7e7 c4a7e7 907aa9]
    [hi-low  21202e 2a283e f4ede8]
    [hi-med  403d52 44415a dfdad9]
    [hi-high 524f67 56526e cecacd]
  ]
}
#+end_src

**** Completion functions

We won't use this interactively much, but if we did...here's some completions

#+begin_src nushell
def variants [] {
  themes | columns | drop nth 0
}
#+end_src

#+begin_src nushell
def role [] {
  themes | get role
}
#+end_src

#+begin_src nushell
def format [] {
  [argb rgb]
}
#+end_src

*** Main function

Finally, we'll bring it all together in a single lil function.

#+begin_src nushell
export def main [
  variant: string@variants,
  role: string@role,
] {
  themes | where role == $role
    | (get $variant).0
}
#+end_src

** Window Manager
:PROPERTIES:
:header-args:nushell: :tangle (expand-file-name "wm.nu" (org-sbe nu-primary-lib-dir)) :mkdirp t :comments link
:END:

We're using [[https://github.com/koekeishiya/yabai][yabai]] as our window manager, and [[https://github.com/koekeishiya/skhd][skhd]] to handle our hotkey invocations. While SKHD is configured elsewhere, we will want to create a file with our yabai-specific bindings. We can weave these key declarations in to this document if we can grab the default file location as a variable to use while tangling.

#+name: skhdrc
#+begin_src nushell :tangle no :cache yes
(xdg config skhd yabai)
#+end_src

#+RESULTS[a42a2981f8f042a44dad4233808a9017c5e90f80]: skhdrc
: /Users/michael/.config/skhd/yabai

*** root

#+begin_src nushell
# Restart the window manager
export def restart [] {
  use service.nu
  service restart yabai
}

# Commands for working with the window manager
export def main [] {
  help wm
}
#+end_src

*** mode

#+begin_src nushell
export module mode {
    use rose-pine

    export def default [] {
        print "DEFAULT mode"
        (
            borders
            $"active_color=0xff(rose-pine dark foam)"
            $"inactive_color=0x88(rose-pine dark base)"
            style=round
            width=8
        )
    }

    export def win [] {
        print "WIN mode"
        (
            borders
            width=12
            style=round
            $"active_color=0xff(rose-pine dark gold)"
            $"inactive_color=0x44(rose-pine dark base)"
        )
    }

    export def spc [] {
        print "SPC mode"
        (
            borders
            width=16
            style=square
            $"active_color=0xff(rose-pine dark love)"
            $"inactive_color=0x88(rose-pine dark rose)"
        )
    }

    export def go-back [] {
        print "Go back one mode"
        skhd -k escape
    }

    export def goto-root [] {
        print "Return to root mode"
        skhd -k shift - escape
    }
}
#+end_src

*** space

#+begin_src nushell
export module space {
    export def equalize [] {
        yabai -m space --equalize
    }

    export def balance [] {
        yabai -m space --balance
    }

    export def create [] {
        yabai -m space --create
    }

    export def destroy [] {
        let id = (yabai -m query --displays --display | from json
            | get spaces | last)
        yabai -m space --destroy $id
    }

    export def flip-x [] {
        yabai -m space --mirror x-axis
    }

    export def flip-y [] {
        yabai -m space --mirror y-axis
    }

    export def flip-xy [] {
        flip-x
        flip-y
    }

    export module focus {
        export def main [selector: string] {
            yabai -m space --focus $selector
        }

        export def next [] {
            yabai -m space --focus next
            sleep 0.2sec
            yabai -m window --focus first
        }

        export def prev [] {
            yabai -m space --focus prev
            sleep 0.2sec
            yabai -m window --focus first
        }
    }

    export module rotate {
        export def cw [] {
            yabai -m space --rotate 270
        }

        export def ccw [] {
            yabai -m space --rotate 90
        }

        export def main [] {
            ccw
        }
    }
}
#+end_src

*** window

#+begin_src nushell
export module window {
#+end_src

- [X] size
  #+begin_src nushell
  export module size {
    export def "ratio increase" [] {
      yabai -m window --ratio rel:0.05
    }

    export def "ratio decrease" [] {
      yabai -m window --ratio rel:-0.05
    }
  }
  #+end_src
- [X] focus
  #+begin_src nushell
  export module focus {
    export def east [] {
      try { yabai -m window --focus east } catch { yabai -m display --focus east }
    }

    export def south [] {
      yabai -m window --focus south
    }

    export def north [] {
      yabai -m window --focus north
    }

    export def west [] {
      try { yabai -m window --focus west } catch { yabai -m display --focus west }
    }

    export def next [] {
      try {
        yabai -m window --focus next
      } catch {
        try {
          yabai -m display --focus next
          yabai -m window --focus first
        } catch {
          yabai -m display --focus first
          yabai -m window --focus first
        }
      }
    }

    export def prev [] {
      try {
        yabai -m window --focus prev
      } catch {
        try {
          (yabai -m query --spaces --display prev | from json
            | where is-visible == true | first
            | yabai -m query --spaces --space $in.index | from json
            | get last-window
            | yabai -m window --focus $in)
        } catch {
          (yabai -m query --spaces --display last | from json
            | where is-visible == true | get 0.index
            | yabai -m query --spaces --space $in | from json
            | get last-window
            | yabai -m window --focus $in)
        }
      }
    }

    export def "stack next" [] {
      (try { yabai -m window --focus stack.next }
        catch { yabai -m window --focus stack.first })
    }

    export def "stack prev" [] {
      (try { yabai -m window --focus stack.prev }
        catch { yabai -m window --focus stack.last })
    }
  }
  #+end_src 
- [X] swap
  #+begin_src nushell
  export module swap {
    export def west [] {
      try {
        yabai -m window --swap west
      } catch {
        let id = (yabai -m query --windows --window | from json
          | get id)
        yabai -m window --display west
        yabai -m window --focus $id
      }
    }

    export def south [] {
      yabai -m window --swap south
    }

    export def north [] {
      yabai -m window --swap north
    }

    export def east [] {
      try {
        yabai -m window --swap east
      } catch {
        let id = (yabai -m query --windows --window | from json
          | get id)
        yabai -m window --display east
        yabai -m window --focus $id
      }
    }

    export def next [] {
      yabai -m window --swap next
    }

    export def prev [] {
      yabai -m window --swap prev
    }
  }
  #+end_src
- [X] warp
  #+begin_src nushell
  export module warp {
    export def west [] {
      yabai -m window --warp west
    }

    export def south [] {
      yabai -m window --warp south
    }

    export def north [] {
      yabai -m window --warp north
    }

    export def east [] {
      yabai -m window --warp east
    }
  }
  #+end_src
- [X] zoom
  #+begin_src nushell
  export module zoom {
    export def get-zoom-state [] {
      (yabai -m query --windows --window | from json
        | if ($in.has-fullscreen-zoom) { 'fullscreen' } else
          if ($in.has-parent-zoom) { 'parent' } else
          {'none'}
        | tee { print $"Current zoom: ($in)" }
        | first)
    }

    def fullscreen [] {
      (yabai -m query --windows --window | from json |
        | if ($in.has-fullscreen-zoom) { return } else {
            toggle-fullscreen
          })
    }

    def parent [] {
      (yabai -m query --windows --window | from json
        | if $in.has-parent-zoom {
            if $in.has-fullscreen-zoom {
              toggle-fullscreen
            }
          } else {
            toggle-parent
          })
    }

    def unzoom [] {
      (yabai -m query --windows --window | from json
        | if ($in.has-parent-zoom) { toggle-parent } else
          if ($in.has-fullscreen-zoom) { toggle-fullscreen })
    }

    export def increase [] {
      match (get-zoom-state) {
        fullscreen => { print "Maximum zoom reached." },
        parent => fullscreen,
        none => parent
      }
    }

    export def decrease [] {
      match (get-zoom-state) {
        fullscreen => parent,
        parent => unzoom,
        none => { print "Minimum zoom reached." }
      }
    }

    export def cycle [] {
      match (get-zoom-state) {
        fullscreen => unzoom,
        parent => fullscreen,
        none => parent
      }
    }

    export def toggle-fullscreen [] {
      yabai -m window --toggle zoom-fullscreen
    }

    export def toggle-parent [] {
      yabai -m window --toggle zoom-parent
    }

  }
  #+end_src
- [X] space
  #+begin_src nushell
  export module space {
    def get-curr-win [] {
      yabai -m query --windows --window | from json | get id
    }

    def with-focus [action: closure] {
      let win = (get-curr-win)
      do $action
      yabai -m window --focus $win
    }

    export def next [] {
      with-focus { yabai -m window --space next }
    }

    export def prev [] {
      with-focus { yabai -m window --space prev }
    }

    export def main [selector: string] {
      with-focus { yabai -m window --space $selector }
    }
  }
  #+end_src
- [X] stack
  #+begin_src nushell
  export module stack {
    def current-win-id [] -> string {
      yabai -m query --windows --window | from json | get id
    }

    def is-stacked [] -> bool {
      yabai -m query --windows --window | from json | get stack-index | $in > 0
    }

    export def next [] {
      if (is-stacked) {
        yabai -m window --stack next
      } else {
        yabai -m window next --stack (current-win-id)
      }
    }

    export def prev [] {
      if (is-stacked) {
        yabai -m window --stack prev
      } else {
        yabai -m window prev --stack (current-win-id)
      }
    }

    export def pop [] {
      for x in 1..2 {
        yabai -m window --toggle float
      }
      balance
    }
  }
  #+end_src
- [X] toggle
  #+begin_src nushell
  export module toggle {
    export def split [] {
      yabai -m window --toggle split
    }
  }
  #+end_src
- [X] display
  #+begin_src nushell
  export module display {
    def with-focus [action: closure] {
      let win = yabai -m query --windows --window | from json | get id
      do $action
      sleep 0.2sec
      yabai -m window --focus $win
    }

    export def next [] {
      with-focus { yabai -m window --display next }
    }

    export def prev [] {
      with-focus { yabai -m window --display prev }
    }

    export def cycle [] {
      with-focus {
        yabai -m window --display next
          | complete
          | if $in.exit_code > 0 {
              yabai -m window --display first
            }
      }
    }
  }
  #+end_src

#+begin_src nushell
}
#+end_src

*** display
#+begin_src nushell
export module display {
#+end_src

- [X] focus
  #+begin_src nushell
  export module focus {
    export def next [--cycle (-c)] {
      yabai -m display --focus next
        | complete
        | if $cycle and $in.exit_code > 0 {
            yabai -m display --focus first
          }
    }

    export def prev [--cycle (-c)] {
      yabai -m display --focus prev
        | complete
        | if $cycle and $in.exit_code > 0 {
            yabai -m display --focus last
          }
    }
  }
  #+end_src

#+begin_src nushell
}
 #+end_src

** TODO Chezmoi
* External Configuration

There are some services that are so tightly integrated with what I'm doing in the shell, it makes sense to define their configuration here.

** ZSH

Because NuShell isn't POSIX compliant, it doesn't make sense to use it for our login =$SHELL=. Lots of programs expect that POSIX compliance from the system shell, so goofing with that isn't a good idea. NuShell knows that, and it lets you inherit environment variables from your system shell that will be available in your =env.nu= and =config.nu= files, as well as any interactive shell. So, let's define our =.zshenv= file here.

#+begin_src sh :tangle ~/.zshenv :eval no :comments both
export XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
[[ -d $XDG_CONFIG_HOME/zsh ]] && export ZDOTDIR="$XDG_CONFIG_HOME/zsh"
source "$ZDOTDIR/.zshenv"
#+end_src

*** Env Configuration
:PROPERTIES:
:header-args:sh: :tangle ~/.config/zsh/.zshenv :eval no :mkdirp t :comments both
:END:

Of course, this doesn't actually give us what we want. It just asks =zsh= if it would kindly load the =.zshenv= file located in the =XDG_CONFIG_HOME= directory instead. But, here's were we can define the actual environment.

**** XDG

#+begin_src sh
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_STATE_HOME="$HOME/.local/state"
export XDG_CACHE_HOME="$HOME/.cache"
export XDG_CONFIG_DIRS=""
export XDG_DATA_DIRS=""
export XDG_RUNTIME_DIR="$TMPDIR"
#+end_src

**** Browser

#+begin_src sh
if [[ -z "$BROWSER" && "$OSTYPE" == darwin* ]]; then
  export BROWSER='open'
fi
#+end_src

**** Editors

#+begin_src sh
export LIFESTYLE="emacs" # emacs, vim

if [[ "$LIFESTYLE" == emacs ]]; then
  export EMACS_SOCKET_NAME="${XDG_RUNTIME_DIR}emacs/server"
  export EDITOR='emacsclient --create-frame --tty'
else
  export EDITOR='nvim'
fi

if [[ "$LIFESTYLE" == emacs ]]; then
  export VISUAL='emacsclient --create-frame'
else
  export VISUAL='neovide --no-fork'
fi
#+end_src

**** Pagers

#+begin_src sh
export PAGER='less'
export MANPAGER='nvim +Man!'
export MANWIDTH=999
#+end_src

**** Language

#+begin_src sh
if [[ -z "$LANG" ]]; then
  export LANG='en_US.UTF-8'
fi
#+end_src

**** Paths

#+begin_src sh
typeset -gU cdpath fpath mailpath path

path=(
  $HOME/{,s}bin(N)
  $HOME/.local/bin
  $HOME/bin
  $HOME/.config/phpmon/bin
  $HOME/.config/emacs/bin
  $HOME/.local/share/bob/nvim-bin
  /opt/{homebrew,local}/{,s}bin(N)
  /usr/local/{,s}bin(N)
  $path
)

fpath=(
  /opt/homebrew/share/zsh/site-functions
  $fpath
)
#+end_src

**** Less

#+begin_src sh
if [[ -z "$LESS" ]]; then
  export LESS='-g -i -M -R -S -w -X -z-4'
fi

if [[ -z "$LESSOPEN" ]] && (( $#commands[(i)lesspipe(|.sh)] )); then
  export LESSOPEN="| /usr/bin/env $commands[(i)lesspipe(|.sh)] %s 2>&-"
fi

export LESSHISTFILE="XDG_CONFIG_HOME"/less/history
#+end_src

**** Secrets

#+begin_src sh
if [[ -f "$HOME/.zsecrets" ]]; then
  source "$HOME/.zsecrets"
fi
#+end_src

** Yabai
:PROPERTIES:
:header-args:nushell: :tangle ~/.config/yabai/yabairc :eval no :comments link :mkdirp t
:END:

#+begin_src nushell
#!/usr/bin/env nu --login

# Settings
let padding = 16

# Load the scripting addition
sudo yabai --load-sa

# Global Settings
yabai -m config menubar_opacity 1.0                  # 0-1
yabai -m config mouse_follows_focus on               # on | off
yabai -m config focus_follows_mouse autoraise        # autofocus | autoraise | off
yabai -m config display_arrangement_order horizontal # default | vertical | horizontal
yabai -m config window_origin_display focused        # default | focused | cursor
yabai -m config window_placement first_child         # first_child | second_child
yabai -m config window_zoom_persist off              # on | off
yabai -m config window_shadow float                  # true | false | float
yabai -m config window_opacity on                    # on | off
yabai -m config window_opacity_duration 0.1          # 0-1
yabai -m config active_window_opacity 0.95           # 0-1
yabai -m config normal_window_opacity 0.80           # 0-1
yabai -m config insert_feedback_color 0x88FF0000     # 0xAARRGGBB
yabai -m config split_ratio 0.5                      # 0-1
yabai -m config split_type auto                      # vertical | horizontal | auto
yabai -m config mouse_modifier ctrl                  # cmd | alt | shift | ctrl | fn
yabai -m config mouse_drop_action stack              # swap | stack

# Space Settings
yabai -m config layout bsp                    # bsp | stack | float
yabai -m config top_padding $padding          # int
yabai -m config bottom_padding $padding       # int
yabai -m config left_padding $padding         # int
yabai -m config right_padding $padding        # int
yabai -m config window_gap $padding           # int
yabai -m config external_bar all:40:0

#
# Labeled Spaces
#
[
  primary  secondary notes messages
  meetings media     system
] | do {
  let labels = $in
  yabai -m query --spaces | from json | do {
    let spaces = $in
    ($labels | length) - ($spaces | length) | if ($in > 0) {
      seq 1 $in | each { yabai -m space --create }
    }
    $labels | enumerate | each {|x|
      yabai -m space ($x.index + 1) --label $x.item
    }
  }
}

#
# Rules
#
#[ [label app space];
#  [settings '^System Settings$' system]
#  [whatsapp WhatsApp messages]
#  [messages Messages messages]
#  [telegram Telegram messages]
#  [spotify Spotify media]
#  [clearvpn ClearVPN system]
#  [cleanmymac 'CleanMyMac X' system]
#] | each { items {|k, v| $"($k)=($v)"} | yabai -m rule --add ...$in }

# Signals
yabai -m signal --add label=reload-sa event=dock_did_restart action="sudo yabai --load-sa"
yabai -m signal --add label=focus-wez event=window_created action='yabai -m window $YABAI_WINDOW_ID --focus' app='^wezterm-gui$'
yabai -m signal --add label=spotify event=window_focused app="^Spotify$" action='yabai -m rule --apply spotify'
yabai -m signal --add label=whatsapp event=window_focused app='^WhatsApp$' action='yabai -m rule --apply whatsapp'

# Final Instructions
yabai -m rule --apply

# vim: ft=nu
#+end_src

** SKHD
:PROPERTIES:
:header-args:sh: :tangle ~/.config/skhd/skhdrc :eval no :mkdirp t :comments link
:END:

#+begin_src sh
# Setup modes
# :: default : wm mode default
# :: win @ : wm mode win
# :: spc @ : wm mode spc
# alt - return ; win
# win < s ; spc
# win < escape ; default
# spc < escape ; win
# win < shift - escape ; default
# spc < shift - escape ; default

# DEFAULT Mode
alt - 0x1E : wm space focus next # ]
alt - 0x21 : wm space focus prev # [
alt - 1 : wm space focus 1
alt - 2 : wm space focus 2
alt - 3 : wm space focus 3
alt - 4 : wm space focus 4
alt - 5 : wm space focus 5
alt - 6 : wm space focus 6
alt - 7 : wm space focus 7
alt - 8 : wm space focus 8
alt - 9 : wm space focus 9
alt - d : wm display focus next --cycle
alt - e : wm space balance
alt - h : wm window focus west
alt - i : wm window focus stack next
alt - j : wm window focus south
alt - k : wm window focus north
alt - l : wm window focus east
alt - n : wm window focus next
alt - o : wm window focus stack prev
alt - p : wm window focus prev
alt - r : wm window toggle split
alt - return : wm window zoom toggle-fullscreen
alt - s : wm space create
alt - space : wm window zoom toggle-parent
alt - u : wm window stack pop
alt - x : wm space flip-x
alt - y : wm space flip-y

alt + shift - 0x18 : wm window size ratio increase # =
alt + shift - 0x1B : wm window size ratio decrease # -
alt + shift - 0x1E : wm window space next # ]
alt + shift - 0x21 : wm window space prev # [
alt + shift - 1 : wm window space 1
alt + shift - 2 : wm window space 2
alt + shift - 3 : wm window space 3
alt + shift - 4 : wm window space 4
alt + shift - 5 : wm window space 5
alt + shift - 6 : wm window space 6
alt + shift - 7 : wm window space 7
alt + shift - 8 : wm window space 8
alt + shift - 9 : wm window space 9
alt + shift - d : wm window display cycle
alt + shift - e : wm space equalize
alt + shift - h : wm window swap west
alt + shift - j : wm window swap south
alt + shift - k : wm window swap north
alt + shift - l : wm window swap east
alt + shift - n : wm window swap next
alt + shift - p : wm window swap prev
alt + shift - r : wm space rotate cw; wm mode go-back
alt + shift - s : wm space destroy

ctrl + alt - h : wm window warp west
ctrl + alt - i : wm window stack next
ctrl + alt - j : wm window warp south
ctrl + alt - k : wm window warp north
ctrl + alt - l : wm window warp east
ctrl + alt - o : wm window stack prev
ctrl + alt - u : wm window stack pop

cmd + alt + ctrl - r : wm reload
#+end_src

* COMMENT Local Variables

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda nil (org-babel-tangle)) nil t)
# End:
